// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task.proto

#ifndef PROTOBUF_task_2eproto__INCLUDED
#define PROTOBUF_task_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace blaze {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_task_2eproto();
void protobuf_AssignDesc_task_2eproto();
void protobuf_ShutdownFile_task_2eproto();

class DataMsg;
class TaskMsg;
class AccMsg;
class AccMsg_KeyValue;

enum MsgType {
  ACCREQUEST = 0,
  ACCGRANT = 1,
  ACCREJECT = 2,
  ACCFINISH = 3,
  ACCDATA = 4,
  ACCFAILURE = 5,
  ACCBROADCAST = 6,
  ACCTERM = 7,
  ACCREGISTER = 8,
  ACCDELETE = 9
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = ACCREQUEST;
const MsgType MsgType_MAX = ACCDELETE;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================

class DataMsg : public ::google::protobuf::Message {
 public:
  DataMsg();
  virtual ~DataMsg();

  DataMsg(const DataMsg& from);

  inline DataMsg& operator=(const DataMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMsg& default_instance();

  void Swap(DataMsg* other);

  // implements Message ----------------------------------------------

  DataMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMsg& from);
  void MergeFrom(const DataMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 partition_id = 1;
  inline bool has_partition_id() const;
  inline void clear_partition_id();
  static const int kPartitionIdFieldNumber = 1;
  inline ::google::protobuf::int64 partition_id() const;
  inline void set_partition_id(::google::protobuf::int64 value);

  // optional bool cached = 2;
  inline bool has_cached() const;
  inline void clear_cached();
  static const int kCachedFieldNumber = 2;
  inline bool cached() const;
  inline void set_cached(bool value);

  // optional bool sampled = 3;
  inline bool has_sampled() const;
  inline void clear_sampled();
  static const int kSampledFieldNumber = 3;
  inline bool sampled() const;
  inline void set_sampled(bool value);

  // optional int32 element_length = 4;
  inline bool has_element_length() const;
  inline void clear_element_length();
  static const int kElementLengthFieldNumber = 4;
  inline ::google::protobuf::int32 element_length() const;
  inline void set_element_length(::google::protobuf::int32 value);

  // optional int32 element_size = 5;
  inline bool has_element_size() const;
  inline void clear_element_size();
  static const int kElementSizeFieldNumber = 5;
  inline ::google::protobuf::int32 element_size() const;
  inline void set_element_size(::google::protobuf::int32 value);

  // optional int32 num_elements = 6;
  inline bool has_num_elements() const;
  inline void clear_num_elements();
  static const int kNumElementsFieldNumber = 6;
  inline ::google::protobuf::int32 num_elements() const;
  inline void set_num_elements(::google::protobuf::int32 value);

  // optional int64 scalar_value = 7;
  inline bool has_scalar_value() const;
  inline void clear_scalar_value();
  static const int kScalarValueFieldNumber = 7;
  inline ::google::protobuf::int64 scalar_value() const;
  inline void set_scalar_value(::google::protobuf::int64 value);

  // optional string file_path = 8;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 8;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // optional int64 file_size = 9;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 9;
  inline ::google::protobuf::int64 file_size() const;
  inline void set_file_size(::google::protobuf::int64 value);

  // optional int64 file_offset = 10;
  inline bool has_file_offset() const;
  inline void clear_file_offset();
  static const int kFileOffsetFieldNumber = 10;
  inline ::google::protobuf::int64 file_offset() const;
  inline void set_file_offset(::google::protobuf::int64 value);

  // optional string mask_path = 11;
  inline bool has_mask_path() const;
  inline void clear_mask_path();
  static const int kMaskPathFieldNumber = 11;
  inline const ::std::string& mask_path() const;
  inline void set_mask_path(const ::std::string& value);
  inline void set_mask_path(const char* value);
  inline void set_mask_path(const char* value, size_t size);
  inline ::std::string* mutable_mask_path();
  inline ::std::string* release_mask_path();
  inline void set_allocated_mask_path(::std::string* mask_path);

  // optional int32 bankID = 12;
  inline bool has_bankID() const;
  inline void clear_bankID();
  static const int kBankIDFieldNumber = 12;
  inline ::google::protobuf::int32 bankID() const;
  inline void set_bankID(::google::protobuf::int32 value);



  // @@protoc_insertion_point(class_scope:blaze.DataMsg)
 private:
  inline void set_has_partition_id();
  inline void clear_has_partition_id();
  inline void set_has_cached();
  inline void clear_has_cached();
  inline void set_has_sampled();
  inline void clear_has_sampled();
  inline void set_has_element_length();
  inline void clear_has_element_length();
  inline void set_has_element_size();
  inline void clear_has_element_size();
  inline void set_has_num_elements();
  inline void clear_has_num_elements();
  inline void set_has_scalar_value();
  inline void clear_has_scalar_value();
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_file_offset();
  inline void clear_has_file_offset();
  inline void set_has_mask_path();
  inline void clear_has_mask_path();

  inline void set_has_bankID();
  inline void clear_has_bankID();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 partition_id_;
  bool cached_;
  bool sampled_;
  ::google::protobuf::int32 element_length_;
  ::google::protobuf::int32 element_size_;
  ::google::protobuf::int32 num_elements_;
  ::google::protobuf::int64 scalar_value_;
  ::std::string* file_path_;
  ::google::protobuf::int64 file_size_;
  ::google::protobuf::int64 file_offset_;
  ::std::string* mask_path_;
  ::google::protobuf::int32 bankID_;

  mutable int _cached_size_;
  //::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static DataMsg* default_instance_;
};
// -------------------------------------------------------------------

class TaskMsg : public ::google::protobuf::Message {
 public:
  TaskMsg();
  virtual ~TaskMsg();

  TaskMsg(const TaskMsg& from);

  inline TaskMsg& operator=(const TaskMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskMsg& default_instance();

  void Swap(TaskMsg* other);

  // implements Message ----------------------------------------------

  TaskMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskMsg& from);
  void MergeFrom(const TaskMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .blaze.MsgType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::blaze::MsgType type() const;
  inline void set_type(::blaze::MsgType value);

  // optional string app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline const ::std::string& app_id() const;
  inline void set_app_id(const ::std::string& value);
  inline void set_app_id(const char* value);
  inline void set_app_id(const char* value, size_t size);
  inline ::std::string* mutable_app_id();
  inline ::std::string* release_app_id();
  inline void set_allocated_app_id(::std::string* app_id);

  // optional string acc_id = 3;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 3;
  inline const ::std::string& acc_id() const;
  inline void set_acc_id(const ::std::string& value);
  inline void set_acc_id(const char* value);
  inline void set_acc_id(const char* value, size_t size);
  inline ::std::string* mutable_acc_id();
  inline ::std::string* release_acc_id();
  inline void set_allocated_acc_id(::std::string* acc_id);

  // repeated .blaze.DataMsg data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::blaze::DataMsg& data(int index) const;
  inline ::blaze::DataMsg* mutable_data(int index);
  inline ::blaze::DataMsg* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg >*
      mutable_data();

  // optional .blaze.AccMsg acc = 5;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 5;
  inline const ::blaze::AccMsg& acc() const;
  inline ::blaze::AccMsg* mutable_acc();
  inline ::blaze::AccMsg* release_acc();
  inline void set_allocated_acc(::blaze::AccMsg* acc);

  // optional string msg = 6;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 6;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:blaze.TaskMsg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* app_id_;
  ::std::string* acc_id_;
  ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg > data_;
  ::blaze::AccMsg* acc_;
  ::std::string* msg_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TaskMsg* default_instance_;
};
// -------------------------------------------------------------------

class AccMsg_KeyValue : public ::google::protobuf::Message {
 public:
  AccMsg_KeyValue();
  virtual ~AccMsg_KeyValue();

  AccMsg_KeyValue(const AccMsg_KeyValue& from);

  inline AccMsg_KeyValue& operator=(const AccMsg_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccMsg_KeyValue& default_instance();

  void Swap(AccMsg_KeyValue* other);

  // implements Message ----------------------------------------------

  AccMsg_KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccMsg_KeyValue& from);
  void MergeFrom(const AccMsg_KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:blaze.AccMsg.KeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static AccMsg_KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class AccMsg : public ::google::protobuf::Message {
 public:
  AccMsg();
  virtual ~AccMsg();

  AccMsg(const AccMsg& from);

  inline AccMsg& operator=(const AccMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccMsg& default_instance();

  void Swap(AccMsg* other);

  // implements Message ----------------------------------------------

  AccMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccMsg& from);
  void MergeFrom(const AccMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AccMsg_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // required string acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline const ::std::string& acc_id() const;
  inline void set_acc_id(const ::std::string& value);
  inline void set_acc_id(const char* value);
  inline void set_acc_id(const char* value, size_t size);
  inline ::std::string* mutable_acc_id();
  inline ::std::string* release_acc_id();
  inline void set_allocated_acc_id(::std::string* acc_id);

  // required string platform_id = 2;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 2;
  inline const ::std::string& platform_id() const;
  inline void set_platform_id(const ::std::string& value);
  inline void set_platform_id(const char* value);
  inline void set_platform_id(const char* value, size_t size);
  inline ::std::string* mutable_platform_id();
  inline ::std::string* release_platform_id();
  inline void set_allocated_platform_id(::std::string* platform_id);

  // optional bytes task_impl = 3;
  inline bool has_task_impl() const;
  inline void clear_task_impl();
  static const int kTaskImplFieldNumber = 3;
  inline const ::std::string& task_impl() const;
  inline void set_task_impl(const ::std::string& value);
  inline void set_task_impl(const char* value);
  inline void set_task_impl(const void* value, size_t size);
  inline ::std::string* mutable_task_impl();
  inline ::std::string* release_task_impl();
  inline void set_allocated_task_impl(::std::string* task_impl);

  // repeated .blaze.AccMsg.KeyValue param = 4;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 4;
  inline const ::blaze::AccMsg_KeyValue& param(int index) const;
  inline ::blaze::AccMsg_KeyValue* mutable_param(int index);
  inline ::blaze::AccMsg_KeyValue* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccMsg_KeyValue >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::blaze::AccMsg_KeyValue >*
      mutable_param();

  // @@protoc_insertion_point(class_scope:blaze.AccMsg)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();
  inline void set_has_task_impl();
  inline void clear_has_task_impl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_id_;
  ::std::string* platform_id_;
  ::std::string* task_impl_;
  ::google::protobuf::RepeatedPtrField< ::blaze::AccMsg_KeyValue > param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static AccMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// DataMsg

// optional int64 partition_id = 1;
inline bool DataMsg::has_partition_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataMsg::set_has_partition_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataMsg::clear_has_partition_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataMsg::clear_partition_id() {
  partition_id_ = GOOGLE_LONGLONG(0);
  clear_has_partition_id();
}
inline ::google::protobuf::int64 DataMsg::partition_id() const {
  return partition_id_;
}
inline void DataMsg::set_partition_id(::google::protobuf::int64 value) {
  set_has_partition_id();
  partition_id_ = value;
}

// optional bool cached = 2;
inline bool DataMsg::has_cached() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataMsg::set_has_cached() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataMsg::clear_has_cached() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataMsg::clear_cached() {
  cached_ = false;
  clear_has_cached();
}
inline bool DataMsg::cached() const {
  return cached_;
}
inline void DataMsg::set_cached(bool value) {
  set_has_cached();
  cached_ = value;
}

// optional bool sampled = 3;
inline bool DataMsg::has_sampled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataMsg::set_has_sampled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataMsg::clear_has_sampled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataMsg::clear_sampled() {
  sampled_ = false;
  clear_has_sampled();
}
inline bool DataMsg::sampled() const {
  return sampled_;
}
inline void DataMsg::set_sampled(bool value) {
  set_has_sampled();
  sampled_ = value;
}

// optional int32 element_length = 4;
inline bool DataMsg::has_element_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataMsg::set_has_element_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataMsg::clear_has_element_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataMsg::clear_element_length() {
  element_length_ = 0;
  clear_has_element_length();
}
inline ::google::protobuf::int32 DataMsg::element_length() const {
  return element_length_;
}
inline void DataMsg::set_element_length(::google::protobuf::int32 value) {
  set_has_element_length();
  element_length_ = value;
}

// optional int32 element_size = 5;
inline bool DataMsg::has_element_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataMsg::set_has_element_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataMsg::clear_has_element_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataMsg::clear_element_size() {
  element_size_ = 0;
  clear_has_element_size();
}
inline ::google::protobuf::int32 DataMsg::element_size() const {
  return element_size_;
}
inline void DataMsg::set_element_size(::google::protobuf::int32 value) {
  set_has_element_size();
  element_size_ = value;
}

// optional int32 num_elements = 6;
inline bool DataMsg::has_num_elements() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataMsg::set_has_num_elements() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataMsg::clear_has_num_elements() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataMsg::clear_num_elements() {
  num_elements_ = 0;
  clear_has_num_elements();
}
inline ::google::protobuf::int32 DataMsg::num_elements() const {
  return num_elements_;
}
inline void DataMsg::set_num_elements(::google::protobuf::int32 value) {
  set_has_num_elements();
  num_elements_ = value;
}

// optional int64 scalar_value = 7;
inline bool DataMsg::has_scalar_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataMsg::set_has_scalar_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataMsg::clear_has_scalar_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataMsg::clear_scalar_value() {
  scalar_value_ = GOOGLE_LONGLONG(0);
  clear_has_scalar_value();
}
inline ::google::protobuf::int64 DataMsg::scalar_value() const {
  return scalar_value_;
}
inline void DataMsg::set_scalar_value(::google::protobuf::int64 value) {
  set_has_scalar_value();
  scalar_value_ = value;
}

// optional string file_path = 8;
inline bool DataMsg::has_file_path() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataMsg::set_has_file_path() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataMsg::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataMsg::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& DataMsg::file_path() const {
  return *file_path_;
}
inline void DataMsg::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void DataMsg::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void DataMsg::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMsg::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}
inline ::std::string* DataMsg::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataMsg::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 file_size = 9;
inline bool DataMsg::has_file_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataMsg::set_has_file_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataMsg::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataMsg::clear_file_size() {
  file_size_ = GOOGLE_LONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::int64 DataMsg::file_size() const {
  return file_size_;
}
inline void DataMsg::set_file_size(::google::protobuf::int64 value) {
  set_has_file_size();
  file_size_ = value;
}

// optional int64 file_offset = 10;
inline bool DataMsg::has_file_offset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataMsg::set_has_file_offset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataMsg::clear_has_file_offset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataMsg::clear_file_offset() {
  file_offset_ = GOOGLE_LONGLONG(0);
  clear_has_file_offset();
}
inline ::google::protobuf::int64 DataMsg::file_offset() const {
  return file_offset_;
}
inline void DataMsg::set_file_offset(::google::protobuf::int64 value) {
  set_has_file_offset();
  file_offset_ = value;
}

// optional string mask_path = 11;
inline bool DataMsg::has_mask_path() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataMsg::set_has_mask_path() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataMsg::clear_has_mask_path() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataMsg::clear_mask_path() {
  if (mask_path_ != &::google::protobuf::internal::kEmptyString) {
    mask_path_->clear();
  }
  clear_has_mask_path();
}
inline const ::std::string& DataMsg::mask_path() const {
  return *mask_path_;
}
inline void DataMsg::set_mask_path(const ::std::string& value) {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  mask_path_->assign(value);
}
inline void DataMsg::set_mask_path(const char* value) {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  mask_path_->assign(value);
}
inline void DataMsg::set_mask_path(const char* value, size_t size) {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  mask_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMsg::mutable_mask_path() {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  return mask_path_;
}
inline ::std::string* DataMsg::release_mask_path() {
  clear_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mask_path_;
    mask_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataMsg::set_allocated_mask_path(::std::string* mask_path) {
  if (mask_path_ != &::google::protobuf::internal::kEmptyString) {
    delete mask_path_;
  }
  if (mask_path) {
    set_has_mask_path();
    mask_path_ = mask_path;
  } else {
    clear_has_mask_path();
    mask_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 bankID = 12;
inline bool DataMsg::has_bankID() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataMsg::set_has_bankID() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataMsg::clear_has_bankID() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataMsg::clear_bankID() {
  bankID_ = 0;
  clear_has_bankID();
}
inline ::google::protobuf::int32 DataMsg::bankID() const {
  return bankID_;
}
inline void DataMsg::set_bankID(::google::protobuf::int32 value) {
  set_has_bankID();
  bankID_ = value;
}

// -------------------------------------------------------------------

// TaskMsg

// required .blaze.MsgType type = 1;
inline bool TaskMsg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskMsg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskMsg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::blaze::MsgType TaskMsg::type() const {
  return static_cast< ::blaze::MsgType >(type_);
}
inline void TaskMsg::set_type(::blaze::MsgType value) {
  assert(::blaze::MsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string app_id = 2;
inline bool TaskMsg::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskMsg::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskMsg::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskMsg::clear_app_id() {
  if (app_id_ != &::google::protobuf::internal::kEmptyString) {
    app_id_->clear();
  }
  clear_has_app_id();
}
inline const ::std::string& TaskMsg::app_id() const {
  return *app_id_;
}
inline void TaskMsg::set_app_id(const ::std::string& value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void TaskMsg::set_app_id(const char* value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void TaskMsg::set_app_id(const char* value, size_t size) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskMsg::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  return app_id_;
}
inline ::std::string* TaskMsg::release_app_id() {
  clear_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_id_;
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskMsg::set_allocated_app_id(::std::string* app_id) {
  if (app_id_ != &::google::protobuf::internal::kEmptyString) {
    delete app_id_;
  }
  if (app_id) {
    set_has_app_id();
    app_id_ = app_id;
  } else {
    clear_has_app_id();
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string acc_id = 3;
inline bool TaskMsg::has_acc_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskMsg::set_has_acc_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskMsg::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskMsg::clear_acc_id() {
  if (acc_id_ != &::google::protobuf::internal::kEmptyString) {
    acc_id_->clear();
  }
  clear_has_acc_id();
}
inline const ::std::string& TaskMsg::acc_id() const {
  return *acc_id_;
}
inline void TaskMsg::set_acc_id(const ::std::string& value) {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  acc_id_->assign(value);
}
inline void TaskMsg::set_acc_id(const char* value) {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  acc_id_->assign(value);
}
inline void TaskMsg::set_acc_id(const char* value, size_t size) {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  acc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskMsg::mutable_acc_id() {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  return acc_id_;
}
inline ::std::string* TaskMsg::release_acc_id() {
  clear_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_id_;
    acc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskMsg::set_allocated_acc_id(::std::string* acc_id) {
  if (acc_id_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_id_;
  }
  if (acc_id) {
    set_has_acc_id();
    acc_id_ = acc_id;
  } else {
    clear_has_acc_id();
    acc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .blaze.DataMsg data = 4;
inline int TaskMsg::data_size() const {
  return data_.size();
}
inline void TaskMsg::clear_data() {
  data_.Clear();
}
inline const ::blaze::DataMsg& TaskMsg::data(int index) const {
  return data_.Get(index);
}
inline ::blaze::DataMsg* TaskMsg::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::blaze::DataMsg* TaskMsg::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg >&
TaskMsg::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg >*
TaskMsg::mutable_data() {
  return &data_;
}

// optional .blaze.AccMsg acc = 5;
inline bool TaskMsg::has_acc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskMsg::set_has_acc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskMsg::clear_has_acc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskMsg::clear_acc() {
  if (acc_ != NULL) acc_->::blaze::AccMsg::Clear();
  clear_has_acc();
}
inline const ::blaze::AccMsg& TaskMsg::acc() const {
  return acc_ != NULL ? *acc_ : *default_instance_->acc_;
}
inline ::blaze::AccMsg* TaskMsg::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) acc_ = new ::blaze::AccMsg;
  return acc_;
}
inline ::blaze::AccMsg* TaskMsg::release_acc() {
  clear_has_acc();
  ::blaze::AccMsg* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline void TaskMsg::set_allocated_acc(::blaze::AccMsg* acc) {
  delete acc_;
  acc_ = acc;
  if (acc) {
    set_has_acc();
  } else {
    clear_has_acc();
  }
}

// optional string msg = 6;
inline bool TaskMsg::has_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskMsg::set_has_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskMsg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskMsg::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& TaskMsg::msg() const {
  return *msg_;
}
inline void TaskMsg::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void TaskMsg::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void TaskMsg::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskMsg::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* TaskMsg::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskMsg::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccMsg_KeyValue

// required string key = 1;
inline bool AccMsg_KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccMsg_KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccMsg_KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccMsg_KeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& AccMsg_KeyValue::key() const {
  return *key_;
}
inline void AccMsg_KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AccMsg_KeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AccMsg_KeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccMsg_KeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* AccMsg_KeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccMsg_KeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes value = 2;
inline bool AccMsg_KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccMsg_KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccMsg_KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccMsg_KeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& AccMsg_KeyValue::value() const {
  return *value_;
}
inline void AccMsg_KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AccMsg_KeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AccMsg_KeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccMsg_KeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* AccMsg_KeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccMsg_KeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccMsg

// required string acc_id = 1;
inline bool AccMsg::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccMsg::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccMsg::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccMsg::clear_acc_id() {
  if (acc_id_ != &::google::protobuf::internal::kEmptyString) {
    acc_id_->clear();
  }
  clear_has_acc_id();
}
inline const ::std::string& AccMsg::acc_id() const {
  return *acc_id_;
}
inline void AccMsg::set_acc_id(const ::std::string& value) {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  acc_id_->assign(value);
}
inline void AccMsg::set_acc_id(const char* value) {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  acc_id_->assign(value);
}
inline void AccMsg::set_acc_id(const char* value, size_t size) {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  acc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccMsg::mutable_acc_id() {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  return acc_id_;
}
inline ::std::string* AccMsg::release_acc_id() {
  clear_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_id_;
    acc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccMsg::set_allocated_acc_id(::std::string* acc_id) {
  if (acc_id_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_id_;
  }
  if (acc_id) {
    set_has_acc_id();
    acc_id_ = acc_id;
  } else {
    clear_has_acc_id();
    acc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string platform_id = 2;
inline bool AccMsg::has_platform_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccMsg::set_has_platform_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccMsg::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccMsg::clear_platform_id() {
  if (platform_id_ != &::google::protobuf::internal::kEmptyString) {
    platform_id_->clear();
  }
  clear_has_platform_id();
}
inline const ::std::string& AccMsg::platform_id() const {
  return *platform_id_;
}
inline void AccMsg::set_platform_id(const ::std::string& value) {
  set_has_platform_id();
  if (platform_id_ == &::google::protobuf::internal::kEmptyString) {
    platform_id_ = new ::std::string;
  }
  platform_id_->assign(value);
}
inline void AccMsg::set_platform_id(const char* value) {
  set_has_platform_id();
  if (platform_id_ == &::google::protobuf::internal::kEmptyString) {
    platform_id_ = new ::std::string;
  }
  platform_id_->assign(value);
}
inline void AccMsg::set_platform_id(const char* value, size_t size) {
  set_has_platform_id();
  if (platform_id_ == &::google::protobuf::internal::kEmptyString) {
    platform_id_ = new ::std::string;
  }
  platform_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccMsg::mutable_platform_id() {
  set_has_platform_id();
  if (platform_id_ == &::google::protobuf::internal::kEmptyString) {
    platform_id_ = new ::std::string;
  }
  return platform_id_;
}
inline ::std::string* AccMsg::release_platform_id() {
  clear_has_platform_id();
  if (platform_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_id_;
    platform_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccMsg::set_allocated_platform_id(::std::string* platform_id) {
  if (platform_id_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_id_;
  }
  if (platform_id) {
    set_has_platform_id();
    platform_id_ = platform_id;
  } else {
    clear_has_platform_id();
    platform_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes task_impl = 3;
inline bool AccMsg::has_task_impl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccMsg::set_has_task_impl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccMsg::clear_has_task_impl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccMsg::clear_task_impl() {
  if (task_impl_ != &::google::protobuf::internal::kEmptyString) {
    task_impl_->clear();
  }
  clear_has_task_impl();
}
inline const ::std::string& AccMsg::task_impl() const {
  return *task_impl_;
}
inline void AccMsg::set_task_impl(const ::std::string& value) {
  set_has_task_impl();
  if (task_impl_ == &::google::protobuf::internal::kEmptyString) {
    task_impl_ = new ::std::string;
  }
  task_impl_->assign(value);
}
inline void AccMsg::set_task_impl(const char* value) {
  set_has_task_impl();
  if (task_impl_ == &::google::protobuf::internal::kEmptyString) {
    task_impl_ = new ::std::string;
  }
  task_impl_->assign(value);
}
inline void AccMsg::set_task_impl(const void* value, size_t size) {
  set_has_task_impl();
  if (task_impl_ == &::google::protobuf::internal::kEmptyString) {
    task_impl_ = new ::std::string;
  }
  task_impl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccMsg::mutable_task_impl() {
  set_has_task_impl();
  if (task_impl_ == &::google::protobuf::internal::kEmptyString) {
    task_impl_ = new ::std::string;
  }
  return task_impl_;
}
inline ::std::string* AccMsg::release_task_impl() {
  clear_has_task_impl();
  if (task_impl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_impl_;
    task_impl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccMsg::set_allocated_task_impl(::std::string* task_impl) {
  if (task_impl_ != &::google::protobuf::internal::kEmptyString) {
    delete task_impl_;
  }
  if (task_impl) {
    set_has_task_impl();
    task_impl_ = task_impl;
  } else {
    clear_has_task_impl();
    task_impl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .blaze.AccMsg.KeyValue param = 4;
inline int AccMsg::param_size() const {
  return param_.size();
}
inline void AccMsg::clear_param() {
  param_.Clear();
}
inline const ::blaze::AccMsg_KeyValue& AccMsg::param(int index) const {
  return param_.Get(index);
}
inline ::blaze::AccMsg_KeyValue* AccMsg::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::blaze::AccMsg_KeyValue* AccMsg::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccMsg_KeyValue >&
AccMsg::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::blaze::AccMsg_KeyValue >*
AccMsg::mutable_param() {
  return &param_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace blaze

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blaze::MsgType>() {
  return ::blaze::MsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_task_2eproto__INCLUDED
