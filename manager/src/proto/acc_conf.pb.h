// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: acc_conf.proto

#ifndef PROTOBUF_acc_5fconf_2eproto__INCLUDED
#define PROTOBUF_acc_5fconf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace blaze {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_acc_5fconf_2eproto();
void protobuf_AssignDesc_acc_5fconf_2eproto();
void protobuf_ShutdownFile_acc_5fconf_2eproto();

class AccPlatform;
class AccPlatform_KeyValue;
class AccWorker;
class AccWorker_KeyValue;
class ManagerConf;

enum AccType {
  CPU = 0,
  OpenCL = 1,
  CUDA = 2,
  ZYNQ = 3
};
bool AccType_IsValid(int value);
const AccType AccType_MIN = CPU;
const AccType AccType_MAX = ZYNQ;
const int AccType_ARRAYSIZE = AccType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccType_descriptor();
inline const ::std::string& AccType_Name(AccType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccType_descriptor(), value);
}
inline bool AccType_Parse(
    const ::std::string& name, AccType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccType>(
    AccType_descriptor(), name, value);
}
// ===================================================================

class AccPlatform_KeyValue : public ::google::protobuf::Message {
 public:
  AccPlatform_KeyValue();
  virtual ~AccPlatform_KeyValue();

  AccPlatform_KeyValue(const AccPlatform_KeyValue& from);

  inline AccPlatform_KeyValue& operator=(const AccPlatform_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccPlatform_KeyValue& default_instance();

  void Swap(AccPlatform_KeyValue* other);

  // implements Message ----------------------------------------------

  AccPlatform_KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccPlatform_KeyValue& from);
  void MergeFrom(const AccPlatform_KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:blaze.AccPlatform.KeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_acc_5fconf_2eproto();
  friend void protobuf_AssignDesc_acc_5fconf_2eproto();
  friend void protobuf_ShutdownFile_acc_5fconf_2eproto();

  void InitAsDefaultInstance();
  static AccPlatform_KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class AccPlatform : public ::google::protobuf::Message {
 public:
  AccPlatform();
  virtual ~AccPlatform();

  AccPlatform(const AccPlatform& from);

  inline AccPlatform& operator=(const AccPlatform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccPlatform& default_instance();

  void Swap(AccPlatform* other);

  // implements Message ----------------------------------------------

  AccPlatform* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccPlatform& from);
  void MergeFrom(const AccPlatform& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AccPlatform_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // optional string id = 1 [default = "cpu"];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string path = 2 [default = ""];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string cache_loc = 3 [default = "cpu"];
  inline bool has_cache_loc() const;
  inline void clear_cache_loc();
  static const int kCacheLocFieldNumber = 3;
  inline const ::std::string& cache_loc() const;
  inline void set_cache_loc(const ::std::string& value);
  inline void set_cache_loc(const char* value);
  inline void set_cache_loc(const char* value, size_t size);
  inline ::std::string* mutable_cache_loc();
  inline ::std::string* release_cache_loc();
  inline void set_allocated_cache_loc(::std::string* cache_loc);

  // optional int32 cache_limit = 4 [default = 16];
  inline bool has_cache_limit() const;
  inline void clear_cache_limit();
  static const int kCacheLimitFieldNumber = 4;
  inline ::google::protobuf::int32 cache_limit() const;
  inline void set_cache_limit(::google::protobuf::int32 value);

  // optional int32 scratch_limit = 5 [default = 4];
  inline bool has_scratch_limit() const;
  inline void clear_scratch_limit();
  static const int kScratchLimitFieldNumber = 5;
  inline ::google::protobuf::int32 scratch_limit() const;
  inline void set_scratch_limit(::google::protobuf::int32 value);

  // repeated .blaze.AccPlatform.KeyValue param = 6;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 6;
  inline const ::blaze::AccPlatform_KeyValue& param(int index) const;
  inline ::blaze::AccPlatform_KeyValue* mutable_param(int index);
  inline ::blaze::AccPlatform_KeyValue* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform_KeyValue >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform_KeyValue >*
      mutable_param();

  // repeated .blaze.AccWorker acc = 7;
  inline int acc_size() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 7;
  inline const ::blaze::AccWorker& acc(int index) const;
  inline ::blaze::AccWorker* mutable_acc(int index);
  inline ::blaze::AccWorker* add_acc();
  inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker >&
      acc() const;
  inline ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker >*
      mutable_acc();

  // @@protoc_insertion_point(class_scope:blaze.AccPlatform)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_cache_loc();
  inline void clear_has_cache_loc();
  inline void set_has_cache_limit();
  inline void clear_has_cache_limit();
  inline void set_has_scratch_limit();
  inline void clear_has_scratch_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  static ::std::string* _default_id_;
  ::std::string* path_;
  ::std::string* cache_loc_;
  static ::std::string* _default_cache_loc_;
  ::google::protobuf::int32 cache_limit_;
  ::google::protobuf::int32 scratch_limit_;
  ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform_KeyValue > param_;
  ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker > acc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_acc_5fconf_2eproto();
  friend void protobuf_AssignDesc_acc_5fconf_2eproto();
  friend void protobuf_ShutdownFile_acc_5fconf_2eproto();

  void InitAsDefaultInstance();
  static AccPlatform* default_instance_;
};
// -------------------------------------------------------------------

class AccWorker_KeyValue : public ::google::protobuf::Message {
 public:
  AccWorker_KeyValue();
  virtual ~AccWorker_KeyValue();

  AccWorker_KeyValue(const AccWorker_KeyValue& from);

  inline AccWorker_KeyValue& operator=(const AccWorker_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccWorker_KeyValue& default_instance();

  void Swap(AccWorker_KeyValue* other);

  // implements Message ----------------------------------------------

  AccWorker_KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccWorker_KeyValue& from);
  void MergeFrom(const AccWorker_KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:blaze.AccWorker.KeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_acc_5fconf_2eproto();
  friend void protobuf_AssignDesc_acc_5fconf_2eproto();
  friend void protobuf_ShutdownFile_acc_5fconf_2eproto();

  void InitAsDefaultInstance();
  static AccWorker_KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class AccWorker : public ::google::protobuf::Message {
 public:
  AccWorker();
  virtual ~AccWorker();

  AccWorker(const AccWorker& from);

  inline AccWorker& operator=(const AccWorker& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccWorker& default_instance();

  void Swap(AccWorker* other);

  // implements Message ----------------------------------------------

  AccWorker* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccWorker& from);
  void MergeFrom(const AccWorker& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AccWorker_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // repeated .blaze.AccWorker.KeyValue param = 3;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 3;
  inline const ::blaze::AccWorker_KeyValue& param(int index) const;
  inline ::blaze::AccWorker_KeyValue* mutable_param(int index);
  inline ::blaze::AccWorker_KeyValue* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker_KeyValue >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker_KeyValue >*
      mutable_param();

  // optional string kernel_name = 4;
  inline bool has_kernel_name() const;
  inline void clear_kernel_name();
  static const int kKernelNameFieldNumber = 4;
  inline const ::std::string& kernel_name() const;
  inline void set_kernel_name(const ::std::string& value);
  inline void set_kernel_name(const char* value);
  inline void set_kernel_name(const char* value, size_t size);
  inline ::std::string* mutable_kernel_name();
  inline ::std::string* release_kernel_name();
  inline void set_allocated_kernel_name(::std::string* kernel_name);

  // optional string kernel_path = 5;
  inline bool has_kernel_path() const;
  inline void clear_kernel_path();
  static const int kKernelPathFieldNumber = 5;
  inline const ::std::string& kernel_path() const;
  inline void set_kernel_path(const ::std::string& value);
  inline void set_kernel_path(const char* value);
  inline void set_kernel_path(const char* value, size_t size);
  inline ::std::string* mutable_kernel_path();
  inline ::std::string* release_kernel_path();
  inline void set_allocated_kernel_path(::std::string* kernel_path);

  // @@protoc_insertion_point(class_scope:blaze.AccWorker)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_kernel_name();
  inline void clear_has_kernel_name();
  inline void set_has_kernel_path();
  inline void clear_has_kernel_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* path_;
  ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker_KeyValue > param_;
  ::std::string* kernel_name_;
  ::std::string* kernel_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_acc_5fconf_2eproto();
  friend void protobuf_AssignDesc_acc_5fconf_2eproto();
  friend void protobuf_ShutdownFile_acc_5fconf_2eproto();

  void InitAsDefaultInstance();
  static AccWorker* default_instance_;
};
// -------------------------------------------------------------------

class ManagerConf : public ::google::protobuf::Message {
 public:
  ManagerConf();
  virtual ~ManagerConf();

  ManagerConf(const ManagerConf& from);

  inline ManagerConf& operator=(const ManagerConf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManagerConf& default_instance();

  void Swap(ManagerConf* other);

  // implements Message ----------------------------------------------

  ManagerConf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManagerConf& from);
  void MergeFrom(const ManagerConf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 app_port = 1 [default = 1027];
  inline bool has_app_port() const;
  inline void clear_app_port();
  static const int kAppPortFieldNumber = 1;
  inline ::google::protobuf::int32 app_port() const;
  inline void set_app_port(::google::protobuf::int32 value);

  // optional int32 gam_port = 2 [default = 1028];
  inline bool has_gam_port() const;
  inline void clear_gam_port();
  static const int kGamPortFieldNumber = 2;
  inline ::google::protobuf::int32 gam_port() const;
  inline void set_gam_port(::google::protobuf::int32 value);

  // optional int32 verbose = 3 [default = 0];
  inline bool has_verbose() const;
  inline void clear_verbose();
  static const int kVerboseFieldNumber = 3;
  inline ::google::protobuf::int32 verbose() const;
  inline void set_verbose(::google::protobuf::int32 value);

  // optional string local_dir = 4 [default = "/tmp"];
  inline bool has_local_dir() const;
  inline void clear_local_dir();
  static const int kLocalDirFieldNumber = 4;
  inline const ::std::string& local_dir() const;
  inline void set_local_dir(const ::std::string& value);
  inline void set_local_dir(const char* value);
  inline void set_local_dir(const char* value, size_t size);
  inline ::std::string* mutable_local_dir();
  inline ::std::string* release_local_dir();
  inline void set_allocated_local_dir(::std::string* local_dir);

  // repeated .blaze.AccPlatform platform = 5;
  inline int platform_size() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 5;
  inline const ::blaze::AccPlatform& platform(int index) const;
  inline ::blaze::AccPlatform* mutable_platform(int index);
  inline ::blaze::AccPlatform* add_platform();
  inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform >&
      platform() const;
  inline ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform >*
      mutable_platform();

  // @@protoc_insertion_point(class_scope:blaze.ManagerConf)
 private:
  inline void set_has_app_port();
  inline void clear_has_app_port();
  inline void set_has_gam_port();
  inline void clear_has_gam_port();
  inline void set_has_verbose();
  inline void clear_has_verbose();
  inline void set_has_local_dir();
  inline void clear_has_local_dir();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 app_port_;
  ::google::protobuf::int32 gam_port_;
  ::std::string* local_dir_;
  static ::std::string* _default_local_dir_;
  ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform > platform_;
  ::google::protobuf::int32 verbose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_acc_5fconf_2eproto();
  friend void protobuf_AssignDesc_acc_5fconf_2eproto();
  friend void protobuf_ShutdownFile_acc_5fconf_2eproto();

  void InitAsDefaultInstance();
  static ManagerConf* default_instance_;
};
// ===================================================================


// ===================================================================

// AccPlatform_KeyValue

// required string key = 1;
inline bool AccPlatform_KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccPlatform_KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccPlatform_KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccPlatform_KeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& AccPlatform_KeyValue::key() const {
  return *key_;
}
inline void AccPlatform_KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AccPlatform_KeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AccPlatform_KeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccPlatform_KeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* AccPlatform_KeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccPlatform_KeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool AccPlatform_KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccPlatform_KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccPlatform_KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccPlatform_KeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& AccPlatform_KeyValue::value() const {
  return *value_;
}
inline void AccPlatform_KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AccPlatform_KeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AccPlatform_KeyValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccPlatform_KeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* AccPlatform_KeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccPlatform_KeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccPlatform

// optional string id = 1 [default = "cpu"];
inline bool AccPlatform::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccPlatform::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccPlatform::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccPlatform::clear_id() {
  if (id_ != _default_id_) {
    id_->assign(*_default_id_);
  }
  clear_has_id();
}
inline const ::std::string& AccPlatform::id() const {
  return *id_;
}
inline void AccPlatform::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == _default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AccPlatform::set_id(const char* value) {
  set_has_id();
  if (id_ == _default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AccPlatform::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == _default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccPlatform::mutable_id() {
  set_has_id();
  if (id_ == _default_id_) {
    id_ = new ::std::string(*_default_id_);
  }
  return id_;
}
inline ::std::string* AccPlatform::release_id() {
  clear_has_id();
  if (id_ == _default_id_) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(_default_id_);
    return temp;
  }
}
inline void AccPlatform::set_allocated_id(::std::string* id) {
  if (id_ != _default_id_) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(_default_id_);
  }
}

// optional string path = 2 [default = ""];
inline bool AccPlatform::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccPlatform::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccPlatform::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccPlatform::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& AccPlatform::path() const {
  return *path_;
}
inline void AccPlatform::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void AccPlatform::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void AccPlatform::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccPlatform::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* AccPlatform::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccPlatform::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cache_loc = 3 [default = "cpu"];
inline bool AccPlatform::has_cache_loc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccPlatform::set_has_cache_loc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccPlatform::clear_has_cache_loc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccPlatform::clear_cache_loc() {
  if (cache_loc_ != _default_cache_loc_) {
    cache_loc_->assign(*_default_cache_loc_);
  }
  clear_has_cache_loc();
}
inline const ::std::string& AccPlatform::cache_loc() const {
  return *cache_loc_;
}
inline void AccPlatform::set_cache_loc(const ::std::string& value) {
  set_has_cache_loc();
  if (cache_loc_ == _default_cache_loc_) {
    cache_loc_ = new ::std::string;
  }
  cache_loc_->assign(value);
}
inline void AccPlatform::set_cache_loc(const char* value) {
  set_has_cache_loc();
  if (cache_loc_ == _default_cache_loc_) {
    cache_loc_ = new ::std::string;
  }
  cache_loc_->assign(value);
}
inline void AccPlatform::set_cache_loc(const char* value, size_t size) {
  set_has_cache_loc();
  if (cache_loc_ == _default_cache_loc_) {
    cache_loc_ = new ::std::string;
  }
  cache_loc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccPlatform::mutable_cache_loc() {
  set_has_cache_loc();
  if (cache_loc_ == _default_cache_loc_) {
    cache_loc_ = new ::std::string(*_default_cache_loc_);
  }
  return cache_loc_;
}
inline ::std::string* AccPlatform::release_cache_loc() {
  clear_has_cache_loc();
  if (cache_loc_ == _default_cache_loc_) {
    return NULL;
  } else {
    ::std::string* temp = cache_loc_;
    cache_loc_ = const_cast< ::std::string*>(_default_cache_loc_);
    return temp;
  }
}
inline void AccPlatform::set_allocated_cache_loc(::std::string* cache_loc) {
  if (cache_loc_ != _default_cache_loc_) {
    delete cache_loc_;
  }
  if (cache_loc) {
    set_has_cache_loc();
    cache_loc_ = cache_loc;
  } else {
    clear_has_cache_loc();
    cache_loc_ = const_cast< ::std::string*>(_default_cache_loc_);
  }
}

// optional int32 cache_limit = 4 [default = 16];
inline bool AccPlatform::has_cache_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccPlatform::set_has_cache_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccPlatform::clear_has_cache_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccPlatform::clear_cache_limit() {
  cache_limit_ = 16;
  clear_has_cache_limit();
}
inline ::google::protobuf::int32 AccPlatform::cache_limit() const {
  return cache_limit_;
}
inline void AccPlatform::set_cache_limit(::google::protobuf::int32 value) {
  set_has_cache_limit();
  cache_limit_ = value;
}

// optional int32 scratch_limit = 5 [default = 4];
inline bool AccPlatform::has_scratch_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccPlatform::set_has_scratch_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccPlatform::clear_has_scratch_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccPlatform::clear_scratch_limit() {
  scratch_limit_ = 4;
  clear_has_scratch_limit();
}
inline ::google::protobuf::int32 AccPlatform::scratch_limit() const {
  return scratch_limit_;
}
inline void AccPlatform::set_scratch_limit(::google::protobuf::int32 value) {
  set_has_scratch_limit();
  scratch_limit_ = value;
}

// repeated .blaze.AccPlatform.KeyValue param = 6;
inline int AccPlatform::param_size() const {
  return param_.size();
}
inline void AccPlatform::clear_param() {
  param_.Clear();
}
inline const ::blaze::AccPlatform_KeyValue& AccPlatform::param(int index) const {
  return param_.Get(index);
}
inline ::blaze::AccPlatform_KeyValue* AccPlatform::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::blaze::AccPlatform_KeyValue* AccPlatform::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform_KeyValue >&
AccPlatform::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform_KeyValue >*
AccPlatform::mutable_param() {
  return &param_;
}

// repeated .blaze.AccWorker acc = 7;
inline int AccPlatform::acc_size() const {
  return acc_.size();
}
inline void AccPlatform::clear_acc() {
  acc_.Clear();
}
inline const ::blaze::AccWorker& AccPlatform::acc(int index) const {
  return acc_.Get(index);
}
inline ::blaze::AccWorker* AccPlatform::mutable_acc(int index) {
  return acc_.Mutable(index);
}
inline ::blaze::AccWorker* AccPlatform::add_acc() {
  return acc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker >&
AccPlatform::acc() const {
  return acc_;
}
inline ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker >*
AccPlatform::mutable_acc() {
  return &acc_;
}

// -------------------------------------------------------------------

// AccWorker_KeyValue

// required string key = 1;
inline bool AccWorker_KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccWorker_KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccWorker_KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccWorker_KeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& AccWorker_KeyValue::key() const {
  return *key_;
}
inline void AccWorker_KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AccWorker_KeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AccWorker_KeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccWorker_KeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* AccWorker_KeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccWorker_KeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool AccWorker_KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccWorker_KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccWorker_KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccWorker_KeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& AccWorker_KeyValue::value() const {
  return *value_;
}
inline void AccWorker_KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AccWorker_KeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AccWorker_KeyValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccWorker_KeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* AccWorker_KeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccWorker_KeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccWorker

// required string id = 1;
inline bool AccWorker::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccWorker::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccWorker::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccWorker::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AccWorker::id() const {
  return *id_;
}
inline void AccWorker::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AccWorker::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AccWorker::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccWorker::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* AccWorker::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccWorker::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool AccWorker::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccWorker::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccWorker::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccWorker::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& AccWorker::path() const {
  return *path_;
}
inline void AccWorker::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void AccWorker::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void AccWorker::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccWorker::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* AccWorker::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccWorker::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .blaze.AccWorker.KeyValue param = 3;
inline int AccWorker::param_size() const {
  return param_.size();
}
inline void AccWorker::clear_param() {
  param_.Clear();
}
inline const ::blaze::AccWorker_KeyValue& AccWorker::param(int index) const {
  return param_.Get(index);
}
inline ::blaze::AccWorker_KeyValue* AccWorker::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::blaze::AccWorker_KeyValue* AccWorker::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker_KeyValue >&
AccWorker::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::blaze::AccWorker_KeyValue >*
AccWorker::mutable_param() {
  return &param_;
}

// optional string kernel_name = 4;
inline bool AccWorker::has_kernel_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccWorker::set_has_kernel_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccWorker::clear_has_kernel_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccWorker::clear_kernel_name() {
  if (kernel_name_ != &::google::protobuf::internal::kEmptyString) {
    kernel_name_->clear();
  }
  clear_has_kernel_name();
}
inline const ::std::string& AccWorker::kernel_name() const {
  return *kernel_name_;
}
inline void AccWorker::set_kernel_name(const ::std::string& value) {
  set_has_kernel_name();
  if (kernel_name_ == &::google::protobuf::internal::kEmptyString) {
    kernel_name_ = new ::std::string;
  }
  kernel_name_->assign(value);
}
inline void AccWorker::set_kernel_name(const char* value) {
  set_has_kernel_name();
  if (kernel_name_ == &::google::protobuf::internal::kEmptyString) {
    kernel_name_ = new ::std::string;
  }
  kernel_name_->assign(value);
}
inline void AccWorker::set_kernel_name(const char* value, size_t size) {
  set_has_kernel_name();
  if (kernel_name_ == &::google::protobuf::internal::kEmptyString) {
    kernel_name_ = new ::std::string;
  }
  kernel_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccWorker::mutable_kernel_name() {
  set_has_kernel_name();
  if (kernel_name_ == &::google::protobuf::internal::kEmptyString) {
    kernel_name_ = new ::std::string;
  }
  return kernel_name_;
}
inline ::std::string* AccWorker::release_kernel_name() {
  clear_has_kernel_name();
  if (kernel_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = kernel_name_;
    kernel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccWorker::set_allocated_kernel_name(::std::string* kernel_name) {
  if (kernel_name_ != &::google::protobuf::internal::kEmptyString) {
    delete kernel_name_;
  }
  if (kernel_name) {
    set_has_kernel_name();
    kernel_name_ = kernel_name;
  } else {
    clear_has_kernel_name();
    kernel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string kernel_path = 5;
inline bool AccWorker::has_kernel_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccWorker::set_has_kernel_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccWorker::clear_has_kernel_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccWorker::clear_kernel_path() {
  if (kernel_path_ != &::google::protobuf::internal::kEmptyString) {
    kernel_path_->clear();
  }
  clear_has_kernel_path();
}
inline const ::std::string& AccWorker::kernel_path() const {
  return *kernel_path_;
}
inline void AccWorker::set_kernel_path(const ::std::string& value) {
  set_has_kernel_path();
  if (kernel_path_ == &::google::protobuf::internal::kEmptyString) {
    kernel_path_ = new ::std::string;
  }
  kernel_path_->assign(value);
}
inline void AccWorker::set_kernel_path(const char* value) {
  set_has_kernel_path();
  if (kernel_path_ == &::google::protobuf::internal::kEmptyString) {
    kernel_path_ = new ::std::string;
  }
  kernel_path_->assign(value);
}
inline void AccWorker::set_kernel_path(const char* value, size_t size) {
  set_has_kernel_path();
  if (kernel_path_ == &::google::protobuf::internal::kEmptyString) {
    kernel_path_ = new ::std::string;
  }
  kernel_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccWorker::mutable_kernel_path() {
  set_has_kernel_path();
  if (kernel_path_ == &::google::protobuf::internal::kEmptyString) {
    kernel_path_ = new ::std::string;
  }
  return kernel_path_;
}
inline ::std::string* AccWorker::release_kernel_path() {
  clear_has_kernel_path();
  if (kernel_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = kernel_path_;
    kernel_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccWorker::set_allocated_kernel_path(::std::string* kernel_path) {
  if (kernel_path_ != &::google::protobuf::internal::kEmptyString) {
    delete kernel_path_;
  }
  if (kernel_path) {
    set_has_kernel_path();
    kernel_path_ = kernel_path;
  } else {
    clear_has_kernel_path();
    kernel_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ManagerConf

// optional int32 app_port = 1 [default = 1027];
inline bool ManagerConf::has_app_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManagerConf::set_has_app_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManagerConf::clear_has_app_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManagerConf::clear_app_port() {
  app_port_ = 1027;
  clear_has_app_port();
}
inline ::google::protobuf::int32 ManagerConf::app_port() const {
  return app_port_;
}
inline void ManagerConf::set_app_port(::google::protobuf::int32 value) {
  set_has_app_port();
  app_port_ = value;
}

// optional int32 gam_port = 2 [default = 1028];
inline bool ManagerConf::has_gam_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManagerConf::set_has_gam_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManagerConf::clear_has_gam_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManagerConf::clear_gam_port() {
  gam_port_ = 1028;
  clear_has_gam_port();
}
inline ::google::protobuf::int32 ManagerConf::gam_port() const {
  return gam_port_;
}
inline void ManagerConf::set_gam_port(::google::protobuf::int32 value) {
  set_has_gam_port();
  gam_port_ = value;
}

// optional int32 verbose = 3 [default = 0];
inline bool ManagerConf::has_verbose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManagerConf::set_has_verbose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManagerConf::clear_has_verbose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManagerConf::clear_verbose() {
  verbose_ = 0;
  clear_has_verbose();
}
inline ::google::protobuf::int32 ManagerConf::verbose() const {
  return verbose_;
}
inline void ManagerConf::set_verbose(::google::protobuf::int32 value) {
  set_has_verbose();
  verbose_ = value;
}

// optional string local_dir = 4 [default = "/tmp"];
inline bool ManagerConf::has_local_dir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManagerConf::set_has_local_dir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManagerConf::clear_has_local_dir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManagerConf::clear_local_dir() {
  if (local_dir_ != _default_local_dir_) {
    local_dir_->assign(*_default_local_dir_);
  }
  clear_has_local_dir();
}
inline const ::std::string& ManagerConf::local_dir() const {
  return *local_dir_;
}
inline void ManagerConf::set_local_dir(const ::std::string& value) {
  set_has_local_dir();
  if (local_dir_ == _default_local_dir_) {
    local_dir_ = new ::std::string;
  }
  local_dir_->assign(value);
}
inline void ManagerConf::set_local_dir(const char* value) {
  set_has_local_dir();
  if (local_dir_ == _default_local_dir_) {
    local_dir_ = new ::std::string;
  }
  local_dir_->assign(value);
}
inline void ManagerConf::set_local_dir(const char* value, size_t size) {
  set_has_local_dir();
  if (local_dir_ == _default_local_dir_) {
    local_dir_ = new ::std::string;
  }
  local_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManagerConf::mutable_local_dir() {
  set_has_local_dir();
  if (local_dir_ == _default_local_dir_) {
    local_dir_ = new ::std::string(*_default_local_dir_);
  }
  return local_dir_;
}
inline ::std::string* ManagerConf::release_local_dir() {
  clear_has_local_dir();
  if (local_dir_ == _default_local_dir_) {
    return NULL;
  } else {
    ::std::string* temp = local_dir_;
    local_dir_ = const_cast< ::std::string*>(_default_local_dir_);
    return temp;
  }
}
inline void ManagerConf::set_allocated_local_dir(::std::string* local_dir) {
  if (local_dir_ != _default_local_dir_) {
    delete local_dir_;
  }
  if (local_dir) {
    set_has_local_dir();
    local_dir_ = local_dir;
  } else {
    clear_has_local_dir();
    local_dir_ = const_cast< ::std::string*>(_default_local_dir_);
  }
}

// repeated .blaze.AccPlatform platform = 5;
inline int ManagerConf::platform_size() const {
  return platform_.size();
}
inline void ManagerConf::clear_platform() {
  platform_.Clear();
}
inline const ::blaze::AccPlatform& ManagerConf::platform(int index) const {
  return platform_.Get(index);
}
inline ::blaze::AccPlatform* ManagerConf::mutable_platform(int index) {
  return platform_.Mutable(index);
}
inline ::blaze::AccPlatform* ManagerConf::add_platform() {
  return platform_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform >&
ManagerConf::platform() const {
  return platform_;
}
inline ::google::protobuf::RepeatedPtrField< ::blaze::AccPlatform >*
ManagerConf::mutable_platform() {
  return &platform_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace blaze

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blaze::AccType>() {
  return ::blaze::AccType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_acc_5fconf_2eproto__INCLUDED
